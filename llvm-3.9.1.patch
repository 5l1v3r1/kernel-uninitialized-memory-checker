diff -ur llvm-3.9.1-original/tools/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td llvm/tools/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td
--- llvm-3.9.1-original/tools/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td	2016-07-19 03:12:49.000000000 +0700
+++ llvm/tools/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td	2016-12-28 15:22:59.000000000 +0700
@@ -342,6 +342,10 @@
   HelpText<"Check for overflows in the arguments to malloc()">,
   DescFile<"MallocOverflowSecurityChecker.cpp">;
 
+def KernelMemoryDisclosureChecker : Checker<"KernelMemoryDisclosure">,
+  HelpText<"Check for uninitialized kernel memory disclosure">,
+  DescFile<"KernelMemoryDisclosureChecker.cpp">;
+
 } // end "alpha.security"
 
 //===----------------------------------------------------------------------===//
diff -ur llvm-3.9.1-original/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt llvm/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt
--- llvm-3.9.1-original/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt	2016-07-19 03:12:49.000000000 +0700
+++ llvm/tools/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt	2016-12-28 15:27:32.000000000 +0700
@@ -36,6 +36,7 @@
   IvarInvalidationChecker.cpp
   LLVMConventionsChecker.cpp
   LocalizationChecker.cpp
+  KernelMemoryDisclosureChecker.cpp
   MacOSKeychainAPIChecker.cpp
   MacOSXAPIChecker.cpp
   MallocChecker.cpp
diff -ur llvm-3.9.1-original/tools/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp llvm/tools/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp
--- llvm-3.9.1-original/tools/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp	2016-02-13 08:42:54.000000000 -0500
+++ llvm/tools/clang/lib/StaticAnalyzer/Core/HTMLDiagnostics.cpp	2017-02-27 07:59:11.000000000 -0500
@@ -11,6 +11,7 @@
 //
 //===----------------------------------------------------------------------===//
 
+#include "llvm/ADT/SmallSet.h"
 #include "clang/AST/ASTContext.h"
 #include "clang/AST/Decl.h"
 #include "clang/Basic/FileManager.h"
@@ -56,6 +57,10 @@
     return "HTMLDiagnostics";
   }
 
+  bool supportsCrossFileDiagnostics() const override {
+    return true;
+  }
+
   unsigned ProcessMacroPiece(raw_ostream &os,
                              const PathDiagnosticMacroPiece& P,
                              unsigned num);
@@ -69,6 +74,11 @@
 
   void ReportDiag(const PathDiagnostic& D,
                   FilesMade *filesMade);
+
+  // Generate the output for the file represented by FID. path might include nodes outside of that file
+  void GenerateFile(const PathDiagnostic& D, Rewriter &R, const SourceManager& SMgr, const PathPieces& path, FileID FID);
+
+  void GenerateHTMLHeader(const PathDiagnostic& D, Rewriter &R, const FileEntry* Entry, const SourceManager& SMgr, const PathPieces& path, FileID FID, const char *declName);
 };
 
 } // end anonymous namespace
@@ -115,34 +125,26 @@
     }
   }
 
+  //printf("Line %i\n", __LINE__); fflush(stdout);
   if (noDir)
     return;
 
   // First flatten out the entire path to make it easier to use.
   PathPieces path = D.path.flatten(/*ShouldFlattenMacros=*/false);
 
-  // The path as already been prechecked that all parts of the path are
-  // from the same file and that it is non-empty.
-  const SourceManager &SMgr = path.front()->getLocation().getManager();
-  assert(!path.empty());
-  FileID FID =
-    path.front()->getLocation().asLocation().getExpansionLoc().getFileID();
-  assert(FID.isValid());
-
-  // Create a new rewriter to generate HTML.
-  Rewriter R(const_cast<SourceManager&>(SMgr), PP.getLangOpts());
+  //printf("Line %i\n", __LINE__); fflush(stdout);
 
   // Get the function/method name
   SmallString<128> declName("unknown");
   int offsetDecl = 0;
   if (const Decl *DeclWithIssue = D.getDeclWithIssue()) {
-      if (const NamedDecl *ND = dyn_cast<NamedDecl>(DeclWithIssue)) {
+      if (const NamedDecl *ND = dyn_cast<NamedDecl>(DeclWithIssue))
           declName = ND->getDeclName().getAsString();
-      }
 
       if (const Stmt *Body = DeclWithIssue->getBody()) {
           // Retrieve the relative position of the declaration which will be used
           // for the file name
+          const SourceManager &SMgr = path.back()->getLocation().getManager();
           FullSourceLoc L(
               SMgr.getExpansionLoc(path.back()->getLocation().asLocation()),
               SMgr);
@@ -151,32 +153,118 @@
       }
   }
 
-  // Process the path.
-  unsigned n = path.size();
-  unsigned max = n;
+  const SourceManager &SMgr = path.front()->getLocation().getManager();
+  Rewriter R(const_cast<SourceManager&>(SMgr), PP.getLangOpts());
 
-  for (PathPieces::const_reverse_iterator I = path.rbegin(),
-       E = path.rend();
-        I != E; ++I, --n)
-    HandlePiece(R, FID, **I, n, max);
+  // Generate HTML files for every new file the path crosses
+  std::vector<FileID> FileIDs;
+  for (auto I = path.rbegin(), E = path.rend(); I != E; ++I) {
+    FileID FID = (*I)->getLocation().asLocation().getExpansionLoc().getFileID();
+    if (std::find(FileIDs.begin(), FileIDs.end(), FID) != FileIDs.end())
+      continue;
 
-  // Add line numbers, header, footer, etc.
+    FileIDs.push_back(FID);
+    GenerateFile(D, R, SMgr, path, FID);
+  }
 
-  // unsigned FID = R.getSourceMgr().getMainFileID();
-  html::EscapeText(R, FID);
-  html::AddLineNumbers(R, FID);
+  if (FileIDs.size() > 1) {
+    // If there's more that one file in this report, prefix file names to every file
+    for (std::vector<FileID>::iterator I = FileIDs.begin(), E = FileIDs.end(); I != E; I++) {
+      SourceLocation StartLoc = SMgr.getLocForStartOfFile(*I);
+      const FileEntry* Entry = SMgr.getFileEntryForID(*I);
+
+      std::string s;
+      llvm::raw_string_ostream os(s);
+      // TODO: Better styling
+      os << "<h4>" << Entry->getName() << "</h4>";
+      R.InsertTextBefore(StartLoc, os.str());
+    }
 
-  // If we have a preprocessor, relex the file and syntax highlight.
-  // We might not have a preprocessor if we come from a deserialized AST file,
-  // for example.
+    // Then append all the file code tables together at the end of the main file
+    for (std::vector<FileID>::iterator I = FileIDs.begin() + 1, E = FileIDs.end(); I != E; I++) {
+      const RewriteBuffer *Buf = R.getRewriteBufferFor(*I);
+
+      std::string file;
+      llvm::raw_string_ostream o(file);
+      for (RewriteBuffer::iterator BI = Buf->begin(), BE = Buf->end(); BI!=BE; ++BI)
+        o << *BI;
 
-  html::SyntaxHighlight(R, FID, PP);
-  html::HighlightMacros(R, FID, PP);
+      SourceLocation MainFileEndLoc = SMgr.getLocForEndOfFile(SMgr.getMainFileID());
+      R.InsertTextAfter(MainFileEndLoc, o.str());
+    }
+  }
+
+  // Get the rewrite buffer.
+  const RewriteBuffer *Buf = R.getRewriteBufferFor(SMgr.getMainFileID());
+
+  if (!Buf) {
+    llvm::errs() << "warning: no diagnostics generated for main file.\n";
+    return;
+  }
+
+  // Add CSS, header, and footer.
+  const FileEntry* Entry = SMgr.getFileEntryForID(SMgr.getMainFileID());
+  GenerateHTMLHeader(D, R, Entry, SMgr, path, SMgr.getMainFileID(), declName.c_str());
+
+  // Create a path for the target HTML file.
+  int FD;
+  SmallString<128> Model, ResultPath;
+
+  //printf("Line %i\n", __LINE__); fflush(stdout);
+  if (!AnalyzerOpts.shouldWriteStableReportFilename()) {
+      llvm::sys::path::append(Model, Directory, "report-%%%%%%.html");
+      if (std::error_code EC =
+          llvm::sys::fs::make_absolute(Model)) {
+          llvm::errs() << "warning: could not make '" << Model
+                       << "' absolute: " << EC.message() << '\n';
+        return;
+      }
+      if (std::error_code EC =
+          llvm::sys::fs::createUniqueFile(Model, FD, ResultPath)) {
+          llvm::errs() << "warning: could not create file in '" << Directory
+                       << "': " << EC.message() << '\n';
+          return;
+      }
 
-  // Get the full directory name of the analyzed file.
+  } else {
+      int i = 1;
+      std::error_code EC;
+      do {
+          // Find a filename which is not already used
+          std::stringstream filename;
+          Model = "";
+          filename << "report-"
+                   << llvm::sys::path::filename(Entry->getName()).str()
+                   << "-" << declName.c_str()
+                   << "-" << offsetDecl
+                   << "-" << i << ".html";
+          llvm::sys::path::append(Model, Directory,
+                                  filename.str());
+          EC = llvm::sys::fs::openFileForWrite(Model,
+                                               FD,
+                                               llvm::sys::fs::F_RW |
+                                               llvm::sys::fs::F_Excl);
+          if (EC && EC != llvm::errc::file_exists) {
+              llvm::errs() << "warning: could not create file '" << Model
+                           << "': " << EC.message() << '\n';
+              return;
+          }
+          i++;
+      } while (EC);
+  }
 
-  const FileEntry* Entry = SMgr.getFileEntryForID(FID);
+  llvm::raw_fd_ostream os(FD, true);
 
+  if (filesMade)
+    filesMade->addDiagnostic(D, getName(),
+                             llvm::sys::path::filename(ResultPath));
+
+  // Emit the HTML to disk.
+  for (RewriteBuffer::iterator I = Buf->begin(), E = Buf->end(); I!=E; ++I)
+      os << *I;
+}
+
+void HTMLDiagnostics::GenerateHTMLHeader(const PathDiagnostic& D, Rewriter &R, const FileEntry* Entry, const SourceManager& SMgr, const PathPieces& path, FileID FID, const char *declName) {
   // This is a cludge; basically we want to append either the full
   // working directory if we have no directory information.  This is
   // a work in progress.
@@ -192,24 +280,40 @@
   int ColumnNumber = path.back()->getLocation().asLocation().getExpansionColumnNumber();
 
   // Add the name of the file as an <h1> tag.
-
   {
     std::string s;
     llvm::raw_string_ostream os(s);
 
     os << "<!-- REPORTHEADER -->\n"
-      << "<h3>Bug Summary</h3>\n<table class=\"simpletable\">\n"
+       << "<h3>Bug Summary</h3>\n<table class=\"simpletable\">\n"
           "<tr><td class=\"rowname\">File:</td><td>"
-      << html::EscapeText(DirName)
-      << html::EscapeText(Entry->getName())
-      << "</td></tr>\n<tr><td class=\"rowname\">Location:</td><td>"
-         "<a href=\"#EndPath\">line "
-      << LineNumber
-      << ", column "
-      << ColumnNumber
-      << "</a></td></tr>\n"
-         "<tr><td class=\"rowname\">Description:</td><td>"
-      << D.getVerboseDescription() << "</td></tr>\n";
+       << html::EscapeText(DirName)
+       << html::EscapeText(Entry->getName())
+       << "</td></tr>\n<tr><td class=\"rowname\">Warning:</td><td>"
+          "<a href=\"#EndPath\">line "
+       << LineNumber
+       << ", column "
+       << ColumnNumber
+       << "</a><br />"
+       << D.getVerboseDescription() << "</td></tr>\n";
+
+#if 0
+    // The navigation across the extra notes pieces.
+    unsigned NumExtraPieces = 0;
+    for (const auto &Piece : path) {
+      if (const auto *P = dyn_cast<PathDiagnosticNotePiece>(Piece.get())) {
+        int LineNumber =
+            P->getLocation().asLocation().getExpansionLineNumber();
+        int ColumnNumber =
+            P->getLocation().asLocation().getExpansionColumnNumber();
+        os << "<tr><td class=\"rowname\">Note:</td><td>"
+           << "<a href=\"#Note" << NumExtraPieces << "\">line "
+           << LineNumber << ", column " << ColumnNumber << "</a><br />"
+           << P->getString() << "</td></tr>";
+        ++NumExtraPieces;
+      }
+    }
+#endif
 
     // Output any other meta data.
 
@@ -221,6 +325,7 @@
     os << "</table>\n<!-- REPORTSUMMARYEXTRA -->\n"
           "<h3>Annotated Source Code</h3>\n";
 
+    // Insert the text
     R.InsertTextBefore(SMgr.getLocForStartOfFile(FID), os.str());
   }
 
@@ -275,73 +380,52 @@
     R.InsertTextBefore(SMgr.getLocForStartOfFile(FID), os.str());
   }
 
-  // Add CSS, header, and footer.
-
-  html::AddHeaderFooterInternalBuiltinCSS(R, FID, Entry->getName());
+  html::AddHeaderFooterInternalBuiltinCSS(R, SMgr.getMainFileID(), Entry->getName());
+}
 
-  // Get the rewrite buffer.
-  const RewriteBuffer *Buf = R.getRewriteBufferFor(FID);
+void HTMLDiagnostics::GenerateFile(const PathDiagnostic& D, Rewriter &R, const SourceManager& SMgr, const PathPieces& path, FileID FID) {
+  // Process the path.
+  // Maintain the counts of extra note pieces separately.
+  unsigned TotalPieces = path.size();
 
-  if (!Buf) {
-    llvm::errs() << "warning: no diagnostics generated for main file.\n";
-    return;
+  unsigned TotalRegularPieces = TotalPieces;// - TotalNotePieces;
+  unsigned NumRegularPieces = TotalRegularPieces;
+#if 0
+  unsigned TotalNotePieces =
+      std::count_if(path.begin(), path.end(),
+                    [](const std::shared_ptr<PathDiagnosticPiece> &p) {
+                      return isa<PathDiagnosticNotePiece>(*p);
+                    });
+  unsigned NumNotePieces = TotalNotePieces;
+#endif
+
+  for (auto I = path.rbegin(), E = path.rend(); I != E; ++I) {
+#if 0
+    if (isa<PathDiagnosticNotePiece>(I->get())) {
+      // This adds diagnostic bubbles, but not navigation.
+      // Navigation through note pieces would be added later,
+      // as a separate pass through the piece list.
+      HandlePiece(R, FID, **I, NumNotePieces, TotalNotePieces);
+      --NumNotePieces;
+    } else {
+#endif
+      HandlePiece(R, FID, **I, NumRegularPieces, TotalRegularPieces);
+      --NumRegularPieces;
+    //}
   }
 
-  // Create a path for the target HTML file.
-  int FD;
-  SmallString<128> Model, ResultPath;
-
-  if (!AnalyzerOpts.shouldWriteStableReportFilename()) {
-      llvm::sys::path::append(Model, Directory, "report-%%%%%%.html");
-      if (std::error_code EC =
-          llvm::sys::fs::make_absolute(Model)) {
-          llvm::errs() << "warning: could not make '" << Model
-                       << "' absolute: " << EC.message() << '\n';
-        return;
-      }
-      if (std::error_code EC =
-          llvm::sys::fs::createUniqueFile(Model, FD, ResultPath)) {
-          llvm::errs() << "warning: could not create file in '" << Directory
-                       << "': " << EC.message() << '\n';
-          return;
-      }
-
-  } else {
-      int i = 1;
-      std::error_code EC;
-      do {
-          // Find a filename which is not already used
-          std::stringstream filename;
-          Model = "";
-          filename << "report-"
-                   << llvm::sys::path::filename(Entry->getName()).str()
-                   << "-" << declName.c_str()
-                   << "-" << offsetDecl
-                   << "-" << i << ".html";
-          llvm::sys::path::append(Model, Directory,
-                                  filename.str());
-          EC = llvm::sys::fs::openFileForWrite(Model,
-                                               FD,
-                                               llvm::sys::fs::F_RW |
-                                               llvm::sys::fs::F_Excl);
-          if (EC && EC != llvm::errc::file_exists) {
-              llvm::errs() << "warning: could not create file '" << Model
-                           << "': " << EC.message() << '\n';
-              return;
-          }
-          i++;
-      } while (EC);
-  }
+  // Add line numbers, header, footer, etc.
 
-  llvm::raw_fd_ostream os(FD, true);
+  // unsigned FID = R.getSourceMgr().getMainFileID();
+  html::EscapeText(R, FID);
+  html::AddLineNumbers(R, FID);
 
-  if (filesMade)
-    filesMade->addDiagnostic(D, getName(),
-                             llvm::sys::path::filename(ResultPath));
+  // If we have a preprocessor, relex the file and syntax highlight.
+  // We might not have a preprocessor if we come from a deserialized AST file,
+  // for example.
 
-  // Emit the HTML to disk.
-  for (RewriteBuffer::iterator I = Buf->begin(), E = Buf->end(); I!=E; ++I)
-      os << *I;
+  html::SyntaxHighlight(R, FID, PP);
+  html::HighlightMacros(R, FID, PP);
 }
 
 void HTMLDiagnostics::HandlePiece(Rewriter& R, FileID BugFileID,
@@ -385,13 +469,22 @@
   // Create the html for the message.
 
   const char *Kind = nullptr;
+  bool IsNote = false;
+  bool SuppressIndex = (max == 1);
   switch (P.getKind()) {
   case PathDiagnosticPiece::Call:
-      llvm_unreachable("Calls should already be handled");
+      llvm_unreachable("Calls and extra notes should already be handled");
   case PathDiagnosticPiece::Event:  Kind = "Event"; break;
   case PathDiagnosticPiece::ControlFlow: Kind = "Control"; break;
     // Setting Kind to "Control" is intentional.
   case PathDiagnosticPiece::Macro: Kind = "Control"; break;
+#if 0
+  case PathDiagnosticPiece::Note:
+    Kind = "Note";
+    IsNote = true;
+    SuppressIndex = true;
+    break;
+#endif
   }
 
   std::string sbuf;
@@ -399,7 +492,9 @@
 
   os << "\n<tr><td class=\"num\"></td><td class=\"line\"><div id=\"";
 
-  if (num == max)
+  if (IsNote)
+    os << "Note" << num;
+  else if (num == max)
     os << "EndPath";
   else
     os << "Path" << num;
@@ -461,7 +556,7 @@
 
   os << "\">";
 
-  if (max > 1) {
+  if (!SuppressIndex) {
     os << "<table class=\"msgT\"><tr><td valign=\"top\">";
     os << "<div class=\"PathIndex";
     if (Kind) os << " PathIndex" << Kind;
@@ -501,7 +596,7 @@
 
     os << "':\n";
 
-    if (max > 1) {
+    if (!SuppressIndex) {
       os << "</td>";
       if (num < max) {
         os << "<td><div class=\"PathNav\"><a href=\"#";
@@ -523,7 +618,7 @@
   else {
     os << html::EscapeText(P.getString());
 
-    if (max > 1) {
+    if (!SuppressIndex) {
       os << "</td>";
       if (num < max) {
         os << "<td><div class=\"PathNav\"><a href=\"#";
@@ -575,12 +670,13 @@
         I!=E; ++I) {
 
     if (const PathDiagnosticMacroPiece *MP =
-          dyn_cast<PathDiagnosticMacroPiece>(*I)) {
+            dyn_cast<PathDiagnosticMacroPiece>(I->get())) {
       num = ProcessMacroPiece(os, *MP, num);
       continue;
     }
 
-    if (PathDiagnosticEventPiece *EP = dyn_cast<PathDiagnosticEventPiece>(*I)) {
+    if (PathDiagnosticEventPiece *EP =
+            dyn_cast<PathDiagnosticEventPiece>(I->get())) {
       os << "<div class=\"msg msgEvent\" style=\"width:94%; "
             "margin-left:5px\">"
             "<table class=\"msgT\"><tr>"
